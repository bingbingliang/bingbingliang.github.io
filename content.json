[{"title":"面试题","date":"2099-12-11T16:00:00.000Z","path":"/posts/d87f7e0c/","text":"1、表单中 get 与 post 提交方法的区别？1）get 一般情况下是从服务器上获取数据，post 一般情况下是向服务器传送数据。2）get 传送的数据量较小，不能大于 2KB。post 传送的数据量较大，在 php.ini 中默认 8M 。 12post_max_size = 8M; // post 表单提交最大限制upload_max_filesize = 2M; // 上传文件最大限制 3）get 安全性非常低，post 安全性较高。Get 提交后在 URL 中可以看到表单参数。post 是通过 HTTP post 机制，将表单内各个字段与其内容放置在 HTML HEADER 内一起传送到 ACTION 属性所指的 URL 地址，用户看不到这个过程。4）get执行效率却比 Post 方法好。5）post 回退需要重新提交数据、数据类型，get 只能为 ASCII。6）Get 可以被缓存 post不可以。 2、session 与 cookie 的区别？1）cookie 数据存放在客户端上，cookie可以被用户禁用，session 数据放在服务器上的文件中可以进行自定义修改。2）cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗，考虑到安全应当使用 session。3）session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用 COOKIE。4）单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。5）所以个人建议：将登陆信息等重要信息存放为 SESSION其他信息如果需要保留，可以放在 COOKIE 中加密6）cookie 有 5 个参数(名，值，有效期，服务器路径，域名，规定是否通过安全的 HTTPS 连接来传输7）避免所有请求传输cookie 可以设置静态域名。8）cookie只能存字符串，session可以存数组等。 3、数据库中的事务是什么扩展：Innodb 存储引擎（支持事务）；MyISAM 存储引擎（不支持事物、行锁、只能缓存索引不能缓存内容） 事务是作为一个逻辑单元执行的一系列操作，一个逻辑工作单元必须有四个属性，称为ACID（原子性、一致性、隔离性和持久性）属性，只有这样才能成为一个事务。 原子性：事务必须是原子工作单元。对于其数据修改，要么全都执行，要么全都不执行。 一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时，所有的内部数据结构（如 B 树索引或双向链表）都必须是正确的。 隔离性：一个事务的执行不能被其他事务干扰。由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。这称为可串行性，因为它能够重新装载起始数据，并且重播一系列事务，以使数据结束时的状态与原始事务执行的状态相同。 持久性：事务完成之后，它对于系统的影响是永久性的。该修改即使出现系统故障也将一直保持。 begin 开始一个事务rollback 事务回滚commit 事务确认注： rollback 和 commit 不能并列使用，当同时使用时，只有前面一个生效MYSQL 默认是自动提交的 4、PHP 打印 日期strtotime() 函数：将任何英文文本的日期时间描述解析为 Unix 时间戳。 1234567891011&lt;?phpecho date('Y-m-d H:i:s');//现在时间echo '&lt;br&gt;';echo date('Y-m-d H:i:s', strtotime('-1 day')); //前一天echo '&lt;br&gt;';echo date('Y-m-d H:i:s', strtotime('-1 week'));//前一周echo '&lt;br&gt;';echo date('Y-m-d H:i:s', strtotime('next Monday'));//下一个星期一echo '&lt;br&gt;';echo date('Y-m-d H:i:s', strtotime('last Monday'));//上一个星期一echo “现在的时间是： ” .date(h:i:sa); //a - 小写的上午和午后（ am 或 pm） 时间差 123456&lt;?php$startdate = strtotime(\"2012-01-01\");$enddate = strtotime(\"2012-02-14\");// Round()为四舍五入函数$days = round(($enddate-$startdate) / 86400)+1;echo $days; 每一个参数的格式分别表示: a - “am” 或是 “pm”A - “AM” 或是 “PM”d - 几日，二位数字，若不足二位则前面补零; 如: “01” 至 “31”D - 星期几，三个英文字母; 如: “Fri”F - 月份，英文全名; 如: “January”h - 12 小时制的小时; 如: “01” 至 “12”H - 24 小时制的小时; 如: “00” 至 “23”g - 12 小时制的小时，不足二位不补零; 如: “1” 至 12”G - 24 小时制的小时，不足二位不补零; 如: “0” 至 “23”i - 分钟; 如: “00” 至 “59”j - 几日，二位数字，若不足二位不补零; 如: “1” 至 “31”l - 星期几，英文全名; 如: “Friday”m - 月份，二位数字，若不足二位则在前面补零; 如: “01” 至 “12”n - 月份，二位数字，若不足二位则不补零; 如: “1” 至 “12”M - 月份，三个英文字母; 如: “Jan”s - 秒; 如: “00” 至 “59”S - 字尾加英文序数，二个英文字母; 如: “th”，”nd”t - 指定月份的天数; 如: “28” 至 “31”U - 总秒数w - 数字型的星期几，如: “0” (星期日) 至 “6” (星期六)Y - 年，四位数字; 如: “1999”y - 年，二位数字; 如: “99”z - 一年中的第几天; 如: “0” 至 “365” 1）给定一个日期，获取其本月的第一天和最后一天 1234567function getCurMonthFirstDay($date) { return date('Y-m-01', strtotime($date));}function getCurMonthLastDay($date) { return date('Y-m-d', strtotime(date('Y-m-01', strtotime($date)) . ' +1 month -1 day'));} 2）给定一个日期，获取其下月的第一天和最后一天 1234567function getNextMonthFirstDay($date) { return date('Y-m-d', strtotime(date('Y-m-01', strtotime($date)) . ' +1 month'));}function getNextMonthLastDay($date) { return date('Y-m-d', strtotime(date('Y-m-01', strtotime($date)) . ' +2 month -1 day'));} 3）给定一个日期，获取其上月的第一天和最后一天 1234567function getPrevMonthFirstDay($date) { return date('Y-m-d', strtotime(date('Y-m-01', strtotime($date)) . ' -1 month'));}function getPrevMonthLastDay($date) { return date('Y-m-d', strtotime(date('Y-m-01', strtotime($date)) . ' -1 day'));} 5、echo(),print(),print_r()的区别echo：可以一次输出多个值，多个值之间用逗号分隔。echo 是语言结构(language construct)，而并不是真正的函数，因此不能作为表达式的一部分使用。 print()：函数 print()打印一个值（它的参数），如果字符串成功显示则返回 true，否则返回 false。 printf()：源于 C 语言中的 printf()。该函数输出格式化的字符串。 print_r() 和 var_dump()：print_r()可以把字符串和数字简单地打印出来，而数组则以括起来的键和值得列表形式显示，并以 Array 开头。有两个参数，第二个参数为 true 的时候，返回值，而不显示。print_r 和 var_dump 都能输出数组和对象，但 print_r 对布尔型的输出不太明显； var_dump 输出比较详细，一般调试时用得多。 6、能够使 Html 和 PHP 分离开的模板Smarty(Smarty 是一个使用 PHP 写出来的模板引擎，是目前业界最著名的 PHP 模板引擎之一。它分离了逻辑代码和外在的内容，提供了一种易于管理和使用的方法，用来将原本与 HTML 代码混杂在一起 PHP 代码逻辑分离。简单的讲，目的就是要使PHP程序员同前端人员分离，使程序员改变程序的逻辑内容不会影响到前端人员的页面设计，前端人员重新修改页面不会影响到程序的程序逻辑，这在多人合作的项目中显的尤为重要。smarty ， phptal ， template、 PHPlib Template 、 FastTemplate 7、请取出$a 的值并打印出第一个字chr() 返回以数值表达式值为编码的字符。ord() 函数返回字符串第一个字符的 ASCII 值。 1234$a='abcdef';echo $a[0];echo $a{0};echo chr(ord($a)); 8、PHP的魔术方法_ _construct() 构造方法，脚本开始时初始化对象；_ _destruct() 析构方法，脚本结束时销毁对象，回收内存； 扩展：https://www.cnblogs.com/baocheng/p/5607216.html 9、写一个函数，尽可能高效的，从一个标准 url 里取出文件的扩展名12345678910111213例如: http://www.sina.com.cn/abc/de/fg.public string GetExtended(string url){return url.Substring(url.LastIndexOf('.'));}例如: http://www.sina.com.cn/abc/de/fg.php?id=1 需要取出 php 或 .phpfunction getExt($url){ $arr = parse_url($url); $file = basename($arr['path']); // explode() 函数把字符串打散为数组。 $ext = explode(\".\",$file); return $ext[1];} 10、写一个函数，算出两个文件的相对路径123456789101112131415161718$a = '/a/b/c/d/e.php';$b = '/a/b/12/34/c.php';//计算出 $b 相对于 $a 的相对路径应该是 ../../c/d function getRelativePath($a, $b) { $returnPath = array(dirname($b)); $arrA = explode('/', $a); $arrB = explode('/', $returnPath[0]); for ($n = 1, $len = count($arrB); $n < $len; $n++) { if ($arrA[$n] != $arrB[$n]) { break; } } if ($len - $n > 0) { $returnPath = array_merge($returnPath, array_fill(1, $len - $n, '..')); } $returnPath = array_merge($returnPath, array_slice($arrA, $n)); return implode('/', $returnPath);} 11、遍历文件夹及文件123456789101112131415function show($dirs){ $dir = opendir($dirs); echo \"&lt;ul&gt;\"; while($f=readdir($dir)){ if($f!='.' && $f!='..'){ echo \"&lt;li&gt;{$f}&lt;/li&gt;\"; if(is_dir(\"$dirs/{$f}\")){ show(\"$dirs/{$f}\"); } } } echo \"&lt;/ul&gt;\";}show(\"C:\\web\\HTML5Upload\");//show($_SERVER['DOCUMENT_ROOT']); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"https://bingbingliang.github.io/tags/PHP/"}]},{"title":"MySql 面试题-总结","date":"2019-06-24T15:49:57.000Z","path":"/posts/f4fa4a3/","text":"第一题1) 查出平均分大于60分的学生姓名与该学生平均分select students.name,AVG(scores.score) from students join scores on students.id = scores.student_id GROUP BY students.name HAVING AVG(scores.score)>60; 2) 查询各科平均分select course,AVG(score) from scores GROUP BY course; students表 id name 1 小明 2 小红 3 小兰 4 小吕 scores表 id student_id course score 1 1 语文 90 2 1 数学 20 3 1 英语 50 4 2 语文 100 5 2 数学 70 6 2 英语 30 7 3 语文 65 8 3 数学 56 9 3 英语 20 10 4 语文 77 11 4 数学 66 12 4 英语 55 第二题1) 查出平均分大于60分的学生姓名与该学生平均分2) 查询各科平均分students表 id name 1 小明 2 小红 3 小兰 4 小吕 scores表 id student_id yuwen shuxue yingyu 1 1 80 57 56 2 2 68 74 56 3 3 78 90 78 4 4 30 40 50 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"MySql","slug":"MySql","permalink":"https://bingbingliang.github.io/tags/MySql/"}]},{"title":"PHP超全局变量","date":"2019-06-23T05:55:15.000Z","path":"/posts/2f14e44/","text":"PHP 全局变量-超全局变量PHP 中的许多预定义变量都是“超全局的”，这意味着他们在一个脚本的全部作用域都可用。在函数或方法中无需执行 global $variable，就可以访问他们。 这些超全局变量是: $GLOBALS $_SERVER $_REQUEST $_POST $_GET $_FILES $_ENV $_COOKIE $_SESSION $GLOBAL - - -引用全局作用域中可用的全部变量 $GLOBAL 这种全局变量用于在PHP脚本中的任意未知访问全局变量(从函数或方法中均可).PHP在名为$GLOBAL[index]的数组中存储了所有的全局变量,变量的名字就是数组的键. 示例: 1234567891011&lt;?php$x = 75;$y = 25;function addition(){ $GLOBALS['z'] = $GLOBALS['x'] + $GLOBALS['y'];}addition();echo $z;?&gt; $_SERVER $_SERVER 这种超全局变量保存关于报头,路径和脚本位置的信息. 元素/代码 描述 $_SERVER[‘PHP_SELF’] 返回当前执行脚本的文件名 $_SERVER[‘GATWAY_INTERFACE’] 返回服务器使用的CGI规范的版本 $_SERVER[‘SERVER_ADDR’] 返回当前运行脚本所在服务器的IP地址 $_SERVER[‘SERVER_NAME’] 返回当前运行脚本所在服务器的主机名（虚拟域名） $_SERVER[‘SERVER_SOFTWARE’] 返回服务器标识字符串(比如Apache/2.2.24) $_SERVER[‘SERVER_PROTOCOL’] 返回当前通信协议的名称和版本(例如：”HTTP/1.0”) $SERVER[‘REQUEST_METHOD’] 返回访问页面使用的请求方法(例如POST) $SERVER[‘REQUEST_TIME’] 返回请求开始时间戳例如1575457898 $SERVER[‘QUERY_STRING’] 返回查询字符串，如果时通过查询字符串访问此页面 $SERVER[‘HTTP_ACCEPT’] 返回来自当前请求的请求头 $SERVER[‘HTTP_ACCEPT_CHARSET’] 返回来自当前请求的accept＿charset头(例如 utf-8,ISO-8859-1) $SERVER[‘HTTP_HOST’] 返回当前请求的Host头 $SERVER[‘HTTP_REFERER’] 放回当前页面完整的ＵＲＬ(不可靠，因为不是所有用户代理都支持) $SERVER[‘HTTPS’] 是否通过安全HTTP协议查询脚本 $SERVER[‘REMOVE_ADDR’] 返回浏览当前页面的用户的IP地址 $SERVER[‘REMOVE_HOST’] 返回当前页面的用户的主机名 $SERVER[‘REMOVE_PORT’] 返回用户级其上链接到ＷＥＢ服务器所使用的端口号 $SERVER[‘SCRIPT_FILENAME’] 当前当前执行脚本的绝对路径 $SERVER[‘SERVER_ADMIN’] 该值致命了Apache服务器配置文件中的SERVR_ADMIN参数 $SERVER[‘SERVER_PORT’] 返回服务器使用的端口，默认时’80’ $SERVER[‘SERVER_SIGNATURE’] 返回服务器版本和虚拟主机名 $SERVER[‘PATH_TRANSLATED’] 当前脚本所在文件系统(非文档根目录)的基本路径 $SERVER[‘SCRIPT_NAME’] 返回当前脚本的路径 $SERVER[‘SCRIPT_URL’] 返回当前页面的URL $_REQUEST PHP $＿REQUEST 用于收集HTML 表单提交的数据 示例： 123456789101112&lt;html&gt;&lt;body&gt;&lt;form method=\"post\" action=\"&lt;?php echo $_SERVER[PHP_SELF];?&gt;\"&gt;Name:&lt;input type=\"text\" name=\"fname\"&gt;&lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;?php$name = $_REQUEST['fname'];echo $name?&gt;&lt;/body&gt;&lt;/html&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"php","slug":"php","permalink":"https://bingbingliang.github.io/tags/php/"}]},{"title":"递归实现无限极分类","date":"2019-06-21T16:00:00.000Z","path":"/posts/14182/","text":"第一种：index.php 12345678910111213141516171819202122232425262728293031323334&lt;php header(\"Content-type: text/html; charset=utf-8\"); /** * 无限极分类 */ $array = array( 1 => array(\"id\" => 1, \"name\" => \"食物\", \"pid\" => 0), 2 => array(\"id\" => 2, \"name\" => \"衣服\", \"pid\" => 0), 3 => array(\"id\" => 3, \"name\" => \"水果\", \"pid\" => 1), 4 => array(\"id\" => 4, \"name\" => \"蔬菜\", \"pid\" => 1), 5 => array(\"id\" => 5, \"name\" => \"男装\", \"pid\" => 2), 6 => array(\"id\" => 6, \"name\" => \"女装\", \"pid\" => 2), 7 => array(\"id\" => 7, \"name\" => \"苹果\", \"pid\" => 3), 8 => array(\"id\" => 8, \"name\" => \"葡萄\", \"pid\" => 3), 9 => array(\"id\" => 9, \"name\" => \"番茄\", \"pid\" => 4), 10 => array(\"id\" => 10, \"name\" => \"土豆\", \"pid\" => 4), 11 => array(\"id\" => 11, \"name\" => \"T恤\", \"pid\" => 5), 12 => array(\"id\" => 12, \"name\" => \"衬衫\", \"pid\" => 5), 13 => array(\"id\" => 13, \"name\" => \"连衣裙\", \"pid\" => 6), 14 => array(\"id\" => 14, \"name\" => \"短裤\", \"pid\" => 6), ); // 递归实现 function getList ($array, $pid, $tmp = \"\") { for ($i = 1; $i Table('region')->select(); return $this->level_sel($arr,$parent_id=0,$level=0);}// 递归function level_sel($arr,$parent_id=0,$level=0){ // 定义一个静态数组 static $data = array(); foreach($arr as $key=>$val){ if($val['parent_id'] == $parent_id){ $val['level'] == $level; $data[] = $val; $this->level_sel($arr,$val['r_id'],$level+1); } } return $data;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"https://bingbingliang.github.io/tags/PHP/"}]},{"title":"PHP上传大文件 - 配置upload_max_filesize和post_max_size","date":"2019-06-19T16:34:54.000Z","path":"/posts/ac09b59e/","text":"简介：PHP上传大文件所涉及到的 php.ini 配置详解。 upload_max_filesize = 2M该配置是指文件上传大小默认是 2M ，如果超过则会失败。必须更改upload_max_filesize的值，例如：upload_max_filesize = 20M。 post_max_size = 8M该配置是指 POST 的数据最大字节长度是8M。索性将这个也改为20M，让它与 upload_max_filesize 相等即可。 max_execution_time = 30该配置是指每个脚本运行的最长时间，单位：秒。在传大文件的时候，必然传输时间变长，当时间超过30秒时，会报脚本执行超过30秒的错误。所以需要适当调高一点，比如 max_execution_time=60。 max_input_time = 60该配置是指每个脚本可以消耗的时间，单位：秒。也需要适当调高一点，比如 max_input_time=120。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"https://bingbingliang.github.io/tags/PHP/"}]},{"title":"微信公众号 - 获取所有关注者的信息","date":"2019-06-18T16:34:54.000Z","path":"/posts/8aac5384/","text":"简介：使用微信公众号接口一键获取全部关注用户的信息。（openid,nickname,city,country,groupid,targetlist） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223&lt;?php //Get all user infors method with wechat PHP API set_time_limit(0); $count = 0; //appid of wechat $appid = '您的APPID'; //appsecret of wechat $appsecret = '您的appsecret'; //@description: convert the unicode to Chinese characters //@para:target string //@return:handled string function decodeUnicode($str) { return preg_replace_callback('/\\\\\\\\u([0-9a-f]{4})/i', create_function( '$matches', 'return mb_convert_encoding(pack(\"H*\", $matches[1]), \"UTF-8\", \"UCS-2BE\");' ),$str); } //@description: if the access_token is invaild, retrive the access_token and assign to global access_token function isErr($data){ if(array_key_exists('errcode',$data)){ //the limit times to retrive access_token(for there is a upper limit 2000 one day) if($GLOBALS['ERRCount'] > $GLOBALS['UpperLimit']){ return false; } if($data['errcode'] == 40001){ $GLOBALS['ERRCount'] = $GLOBALS['ERRCount'] + 1; $GLOBALS['access_token'] = getaccess_token($appid,$appsecret); return true; } else{ //other error but not access_token invaild return false; } } return false; } //@description:get the access_token function getaccess_token($appid,$appsecret){ //the access_token request url $url = \"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid={$appid}&secret={$appsecret}\"; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL,$url); curl_setopt($ch, CURLOPT_RETURNTRANSFER,1); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER,0); $data = curl_exec($ch); curl_close($ch); //convert json to array $data = json_decode($data,true); return $data['access_token']; } //@description: post method of get 100 user infors(limit:100 once) //@para:the first is access_token,the second is the post data which is a json string(format see wechat API website) //@return: the array of user infors function post($access_token, $post_data = ''){ $url = \"https://api.weixin.qq.com/cgi-bin/user/info/batchget?access_token={$access_token}\"; $ch = curl_init(); curl_setopt ($ch, CURLOPT_URL, $url); curl_setopt ($ch, CURLOPT_POST, 1); curl_setopt ($ch, CURLOPT_POSTFIELDS, $post_data); curl_setopt ($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt ($ch, CURLOPT_HEADER, false); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER,0); // the response data which is the infor json string $data = curl_exec($ch); curl_close($ch); // replace error json string to avoid decode error $data = preg_replace('/[\\x00-\\x1F]/','', $data); $data = json_decode($data,true); //var_dump($data); if(isErr($data)){ //if the access_token is invaild, retrive the new access_token and try again return post($GLOBALS['access_token'],$post_data); } if(array_key_exists('user_info_list',$data)){ return $data['user_info_list']; } } //@description: get the openids list of users(limit:10000 once) //@para: the first is the access_token,the second is the next_openid which could be empty as the default //@return: return the openid list function getOpenid($access_token,$openid=''){ //获取access_token $url = \"https://api.weixin.qq.com/cgi-bin/user/get?access_token={$access_token}&next_openid={$openid}\"; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL,$url); curl_setopt($ch, CURLOPT_RETURNTRANSFER,1); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER,0); $data = curl_exec($ch); curl_close($ch); $data = json_decode($data,true); if(isErr($data)){ return getOpenid($GLOBALS['access_token'],$openid); } return $data; } //@description: write the user infor to file or do other handle //para: user infor array function handInfors($data){ if($data == null){ return; } foreach($data as $infor){ //number count of all users $GLOBALS['InforCount'] = $GLOBALS['InforCount'] + 1; //unicode convert $inforJson = decodeUnicode(json_encode($infor)); //write each line(each user infor) to info.txt $file = 'info.txt'; $current = file_get_contents($file); $current .= $inforJson; $current .= \"\\r\\n\"; file_put_contents($file, $current); } } //@description: send model message to Specified openid //@return: the send response function set_msg($access_token,$openid){ $formwork = '{ \"touser\":\"'.$openid.'\", \"template_id\":\"GkChFMRCGYvGoNUzusXX3qnOOV-6U0L801L3lmp6NYo\", \"url\":\"http://mp.weixin.qq.com/s/Nn7-KIVOR3S8SFBOV3Qw8Q\", \"data\":{ \"first\": { \"value\":\"缠论运行报告\", \"color\":\"#173177\" }, \"keyword1\":{ \"value\":\"缠论\", \"color\":\"#173177\" }, \"keyword2\":{ \"value\":\"国信TradeStation缠论全市场扫描\", \"color\":\"#173177\" }, \"keyword3\":{ \"value\":\"每天\", \"color\":\"#173177\" }, \"remark\": { \"value\":\"2017-3-13：本日，\\n第一类买点：2只，第二类买点：1只，第三类买点：0只；\\n第一类卖点：1只，第二类卖点：0只，第三类卖点：2只；\\n点击查看详情。\", \"color\":\"#FF0000\" } } }'; $url = \"https://api.weixin.qq.com/cgi-bin/message/template/send?access_token={$access_token}\"; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL,$url); curl_setopt($ch, CURLOPT_RETURNTRANSFER,1); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER,0); curl_setopt($ch, CURLOPT_POST,1); curl_setopt($ch, CURLOPT_POSTFIELDS,$formwork); $data = curl_exec($ch); curl_close($ch); return $data; } //@description:get user infor by openid //@return: the user infor Json string function getUserByID($access_token,$openid){ $url = \"https://api.weixin.qq.com/cgi-bin/user/info?access_token={$access_token}&openid={$openid}&lang=zh_CN\"; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL,$url); curl_setopt($ch, CURLOPT_RETURNTRANSFER,1); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER,0); $data = curl_exec($ch); curl_close($ch); return $data;//return the infor json string } //main method: echo date('Y-m-d H:i:s',time()); echo(\"&lt;br&gt;&lt;/br&gt;\"); $access_token = getaccess_token($appid,$appsecret); echo \"access_token：\".$access_token; echo(\"&lt;br&gt;&lt;/br&gt;\"); $ERRCount = 0; $UpperLimit = 10; $InforCount = 0; $data = getOpenid($access_token); //print_r($data); //echo(\"&lt;br&gt;&lt;/br&gt;\"); while(true){ //getOpenid $count = $data['count']; //openids count(10000 or trim) $nextopenid = $data['next_openid']; $list = array(); $tempCount = 0; if(array_key_exists('data',$data) == false){ break; } foreach($data['data']['openid'] as $openid){ $tempCount = $tempCount + 1; $idArray =array( 'openid' => $openid, \"lang\" => \"zh-CN\" ); Array_push($list,$idArray); if(count($list) == 100 or $tempCount == $count){ $arra = array( 'user_list' => $list ); //echo(json_encode($arra)); //print_r($arra); $infors = post($access_token,json_encode($arra)); print_r($infors); echo(\"&lt;br&gt;&lt;/br&gt;\"); //write infors to files handInfors($infors); $list = array(); } } $data = getOpenid($access_token,$nextopenid); } echo date('Y-m-d H:i:s',time()); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"https://bingbingliang.github.io/tags/PHP/"}]},{"title":"微信公众号 - 自定义token对接","date":"2019-06-17T17:55:46.000Z","path":"/posts/e20321f4/","text":"简介：开发微信公众号之前需要先给“微信公众平台”与“自己的服务器”建立一个关系，本篇内容就是“自己的服务器”与“微信公众平台”对接的文件内容。 由于“微信公众号-被动回复用户消息”不需要 appID 和 appsecret ，所以我把该功能也引进了这篇文章。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;?php/** * wechat php test *///define your tokendefine(\"TOKEN\", \"weixin\"); // 自定义‘与微信公众平台-接口配置信息中的 token 一致才能对接成功’$wechatObj = new wechatCallbackapiTest();$wechatObj->valid();class wechatCallbackapiTest { public function valid() { $echoStr = $_GET[\"echostr\"]; //valid signature , option if($this->checkSignature() && $echoStr){ echo $echoStr; exit; } else { $this -> responseMsg(); } } public function responseMsg() { //get post data, May be due to the different environments //$postStr = $GLOBALS[\"HTTP_RAW_POST_DATA\"]; $postStr = file_get_contents(\"php://input\"); //extract post data if (!empty($postStr)){ $postObj = simplexml_load_string($postStr, 'SimpleXMLElement', LIBXML_NOCDATA); if( strtolower($postObj->MsgType) == 'text' && trim($postObj->Content)=='tuwen' ){ $fromUsername = $postObj->FromUserName; $toUsername = $postObj->ToUserName; $arr = array( array( 'title'=>'hao123', 'description'=>\"hao123 is very cool\", 'picUrl'=>'https://www.baidu.com/img/bdlogo.png', 'url'=>'http://www.hao123.com', ), array( 'title'=>'qq', 'description'=>\"qq is very cool\", 'picUrl'=>'http://www.imooc.com/static/img/common/logo.png', 'url'=>'http://www.qq.com', ), array( 'title'=>'imooc', 'description'=>\"imooc is very cool\", 'picUrl'=>'http://www.imooc.com/static/img/common/logo.png', 'url'=>'http://www.imooc.com', ), ); $template = \"&lt;xml&gt; &lt;ToUserName&gt&lt;![CDATA[%s]]&gt&lt;/ToUserName&gt &lt;FromUserName&gt&lt;![CDATA[%s]]&gt&lt;/FromUserName&gt &lt;CreateTime&gt%s&lt;/CreateTime&gt &lt;MsgType&gt&lt;![CDATA[%s]]&gt&lt;/MsgType&gt &lt;ArticleCount&gt3&lt;/ArticleCount&gt &lt;Articles&gt\"; foreach($arr as $k=>$v){ $template .=\"&#60;item&gt; &lt;Title&gt;&lt;![CDATA[\".$v['title'].\"]]&gt;&lt;/Title&gt; &lt;Description&gt;&lt;![CDATA[\".$v['description'].\"]]&gt;&lt;/Description&gt; &lt;PicUrl&gt;&lt;![CDATA[\".$v['picUrl'].\"]]&gt;&lt;/PicUrl&gt; &lt;Url&gt;&lt;![CDATA[\".$v['url'].\"]]&gt;&lt;/Url&gt; &lt;/item&gt;\"; } $template .=\"&lt;/Articles&gt; &lt;/xml&gt;\"; echo sprintf($template, $fromUsername, $toUsername, time(), 'news'); //注意：进行多图文发送时，子图文个数不能超过10个 }else{ $fromUsername = $postObj->FromUserName; $toUsername = $postObj->ToUserName; $keyword = trim($postObj->Content); $time = time(); $textTpl = \"&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;%s&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[%s]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt; &lt;FuncFlag&gt;0&lt;/FuncFlag&gt; &lt;/xml&gt;\"; $msgType = \"text\"; // 判断该数据包是否是订阅的事件推送 if( strtolower( $postObj->MsgType) == 'event'){ // 如果是关注 subscribe 事件 if( strtolower( $postObj->Event == 'subscribe')){ // 回复用户消息 $contentStr = \"欢迎关注我们的微信公众号\"; } }else if( strtolower( $postObj->MsgType) == 'text'){ switch ($keyword) { case 1: $contentStr = \"您输入了数字1\"; break; case 2: $contentStr = \"您输入了数字2\"; break; case '冰冰凉': $contentStr = \"&lt;a href='https://bingbingliang.github.io'&gt;冰冰凉&lt;/a&gt;\"; break; default: $contentStr = \"未匹配到您的输入\"; break; } } $resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr); echo $resultStr; } }else { echo \"\"; exit; } } private function checkSignature() { $signature = $_GET[\"signature\"]; $timestamp = $_GET[\"timestamp\"]; $nonce = $_GET[\"nonce\"]; $token = TOKEN; $tmpArr = array($token, $timestamp, $nonce); sort($tmpArr); $tmpStr = implode( $tmpArr ); $tmpStr = sha1( $tmpStr ); if( $tmpStr == $signature ){ return true; }else{ return false; } }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"https://bingbingliang.github.io/tags/PHP/"}]},{"title":"oAuth2.0 协议 — PHP第三方登录","date":"2019-06-13T16:05:46.000Z","path":"/posts/20764040/","text":"oAuth2.0 协议就是网站在不知道用户 第三方平台（比如：QQ、微博……）账号、密码的情况下，通过 oAuth2.0协议 让第三方平台授权给本网站的能力。此过程中 网站不会知道用户的 QQ账号、QQ密码。所以对于用户而言，他的第三方账户是安全的。之所以说网站不知道用户的 QQ账号和 QQ密码，是因为 用户在输入 QQ账号和 QQ密码的网站弹框页面。不是本网站的页面，而是第三方授权页。从url链接就可以看出来 https://graph.qq.com/oauth2.0/show…… 里面有 oauth2.0 字样。 1、什么是第三方登录？ 所谓的第三方登录就是利用用户在第三方平台上已有的账号快速完成自己应用的登录或注册功能。 而这里的第三方平台，一般是已经有大量用户的平台，如国内的新浪微博、QQ空间、微信、外国的Facebook、twitter等等。 第三方登录不是一个具体的接口，而是一种思想或者一套步骤。 2、为什么要使用第三方登录？ 简单、方便、快捷、深受用户喜欢。 简化注册或登录流程。 3、第三方登录的优点？ 对网站而言无非是简化登陆过程，降低注册门槛，获取海量新用户。 对用户而言，注册简单，一键式的点击成为网站会员，深受用户喜欢。 4、第三方登录的缺点？ 安全性不能保证。 可能造成个人信息泄露。 隐私性不能保证。 不能更详尽的统计用户信息，无法给用户发送本站消息。 5、第三方登录适用场景？ 对于工具型、游戏型、内容型等应用，注重的是工具的使用、内容的提供，适合把第三方登录放在优先的位置，甚至只提供第三方登录就行，免去用户注册。 对于电商类应用，注重自己账号体系的建立、注重用户后续的营销，第三方登录只是作为补充，将第三方登录置于较弱的位置，为没有账号的用户提供快速登录。 对于支付类、金融类应用，强调安全性、强调隐私性，一般不提供第三方登录。如果这些类型应用提供第三方登录，让用户觉得不安全，感觉自己的信息会通过第三方授权泄露出去。 6、第三方登录实现流程。（QQ登录为例） 第一步：用户点击网站第三方登录 - QQ登录，弹出 QQ登录授权页面。 第二步：用户输入 QQ账号和QQ密码点击提交授权。（默认登录成功，第三方QQ授权页返回 用户信息、以及code 参数，告诉网站您已经登录成功）。 第三步：为增加用户信息安全，code 存在的时间很短，所以还有一个隐藏步骤是用户不可见的。网站会通过该 code 参数在请求第三方，获取 Access Token。该 Access Token 是调用 QQ开放接口中的通关令牌，存在一定的有效时间。 7、如何看待第三方登录？ 第一种：传统的注册的方式，注册门槛高，易在登录页面就流失用户。 可能很少app会用，没有留下用户的信息，无法跟踪用户的行为。 第三方注册后系统默认给用户分配一个ID，用户可见也不可见。 第三方注册后还要手动添加数据（给人一种欺骗注册的感觉，让用户讨厌）。 8、三个群体的思考1）用户的角度 第三方登陆方便了用户日常的网络生活，身在一个离不开网络的时代，每天都面对着不同的登陆界面，能有一种简单的登陆方式显得很重要。第三方登陆方便快捷，且很多资料信息可以公用，并可以将自己在某个app的动态信息同步到各个sns平台。于是有些犯懒的用户可能会养成一种“一个账号走江湖”的 心里。 但话说回来，无论什么事只用一种方式处理肯定会在阴沟里翻船的，比如哪天你的微博号被封了，你的QQ号被盗了，株连下来的相关app也不能登录了，注册新账号的话，那么之前你在网络上记录的生活也都回归到零了，那个时候，你又该怎么办呢？ 2）本地客户端角度 对本地应用而言无非是简化登录过程，降低注册门槛，获取海量新用户。 在争抢用户的竞争中，提高用户的转化率是决定能不能突出重围的重要因素。同样的事情都有两面性，我们利用第三方登陆的这种方式，在应程度上是依赖第三方的 一种行为，在知乎上看到一篇很有激情的文章，说的就是关于使用第三方登录都与app应用的限制，链接网址是www.zhihu.com/question/19618841； 虽然有些说的极端了点，但在某种程度上也是对app设计者或者投资人的一种警醒，而对于那种直接去掉本地注册的app，更应该好好思考一下自己app的未来发展，保重啊~~~再者就是用户本事对第三方登录的犹豫，就是关于隐私的暴漏，大家的潜意识下是不想在随便一个app上暴漏自己过多的信息的。 3）第三方角度 第三方账号貌似像个大老板一样，随便给你开个口就可以让你活的好点，把口一掐，估计你是活不太好了，而且可以很好的继续扩大它本身的用户 基数。我目前还没有想到这这种绑定对于这些大boss有什么坏处，在这场以用户数量定输赢的博弈当中，强大的第三方貌似永远是胜者。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"https://bingbingliang.github.io/tags/PHP/"}]},{"title":"PHPStorm 相关操作","date":"2019-01-02T16:00:00.000Z","path":"/posts/13173/","text":"PHPStorm 设置 Ctrl + 滚轮调整字体大小1.点击左上角的File，再点击setting； 2.Editor->General，选择Change font size (Zoom) with Ctrl+Mouse Wheel； 3.点击OK即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"https://bingbingliang.github.io/tags/PHP/"}]},{"title":"MySQL 数据库的常用命令","date":"2018-12-31T16:00:00.000Z","path":"/posts/57951/","text":"如何使用命令行把 sql 文件导入 MySql 数据库1.进入 MySql ：mysql -uroot -p；（配置全局变量的情况下可直接进入，否则需要进入mysql的安装目录bin下进行进入） 2.使用需要导入到的数据库：use 3.导入 sql 文件到当前数据库：source sql 文件路径 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"MySql","slug":"MySql","permalink":"https://bingbingliang.github.io/tags/MySql/"}]},{"title":"Laravel 数据库操作的三种方式","date":"2017-12-31T16:00:00.000Z","path":"/posts/49682/","text":"Laravel提供了3种操作数据库方式：DB facade（原始方式）、查询构造器和Eloquent ORM。 数据库操作之DB facade1.查询操作12//返回一个二维数组DB::select(\"select * from table\"); 2.新增操作12//新增成功则返回trueDB::insert(\"insert into table(vip_ID,vip_name,vip_type,vip_fenshu) values(?,?,?,?)\",[5,'小明','出行',670]); 3.更新操作12//更新成功返回trueDB::update('update vipinfo set vip_fenshu= ? where vip_ID= ? ',[700,5]); 4.删除操作12// 返回的是删除的行数。DB::delete('delete from vipinfo where vip_ID= ?',[5]); 数据库操作之查询构造器一、使用查询构造器实现增删改查1.新增1234567891011$bool=DB::table(\"vipinfo\")->insert(['vip_ID'=>6,'vip_name'=>'zls','vip_type'=>\"出行\",'vip_fenshu'=>800]); echo $bool; //返回bool值 //如果想得到新增的id，则使用insertGetId方法 $id=DB::table(\"vipinfo\")->insertGetId(['vip_ID'=>5,'vip_name'=>'wyp','vip_type'=>\"出行\",'vip_fenshu'=>800]); echo $id; //插入多条数据 $bool=DB::table(\"vipinfo\")->insert([ ['vip_ID'=>5,'vip_name'=>'wyp','vip_type'=>\"出行\",'vip_fenshu'=>800], ['vip_ID'=>6,'vip_name'=>'zls','vip_type'=>\"出行\",'vip_fenshu'=>800], ]); echo $bool; //返回bool值 2.修改1234567891011121314151617181920212223$bool=DB::table(\"vipinfo\")->where('vip_ID',6)->update(['vip_fenshu'=>500]); echo $bool; //自增 $bool=DB::table(\"vipinfo\")->where('vip_ID',6)->increment(\"vip_fenshu\");//自增1 $bool=DB::table(\"vipinfo\")->where('vip_ID',6)->increment(\"vip_fenshu\",3);//自增3 echo $bool; //自减 $bool=DB::table(\"vipinfo\")->where('vip_ID',6)->decrement(\"vip_fenshu\");//自1 $bool=DB::table(\"vipinfo\")->where('vip_ID',6)->decrement(\"vip_fenshu\",3);//自增3 echo $bool; //自增时再修改其他字段 $bool=DB::table(\"vipinfo\")->where('vip_ID',6)->increment(\"vip_fenshu\",3,['vip_name'=>'dbdibi']);//自增3//两个字段同时自增 or 自减 increment// 第一种写法$results = DB::table('articles') ->where('id', $params['id']) ->increment('vote', 1, array('num' => DB::raw('`num` + 1')));// 第二种写法$results = DB::table('articles')->where('id', $params['id'])->update(array( 'vote' => DB::raw('vote + 1'), 'num' => DB::raw('num + 1'),)); 3.删除1234$num=DB::table(\"vipinfo\")->where('vip_ID',6)->delete();//删除1条 $num=DB::table(\"vipinfo\")->where('vip_ID','>',4)->delete();//删除多条 echo $num; //删除的行数 $num=DB::table(\"vipinfo\")->truncate();//删除整表，不能恢复，谨慎使用 4.查询1234567891011121314151617181920212223242526//get()返回多条数据 $student=DB::table(\"vipinfo\")->get(); var_dump($student); //first()返回1条数据 $student=DB::table(\"vipinfo\")->first(); //结果集第一条记录 $student=DB::table(\"vipinfo\")->orderBy('vip_ID','desc')->first();//按vip_ID倒序排序 var_dump($student); //where()条件查询 $student=DB::table(\"vipinfo\")->where('vip_ID','>=',2)->get(); //一个条件 $student=DB::table(\"vipinfo\")->whereRaw('vip_ID> ? and vip_fenshu >= ?',[2,300])->get(); //多个条件 dd($student); //pluck()指定字段,后面不加get $student=DB::table(\"vipinfo\")->pluck('vip_name'); dd($student); //lists()指定字段，可以指定某个字段作为下标 $student=DB::table(\"vipinfo\")->lists('vip_name','vip_ID'); //指定vip_ID为下标 dd($student); $student=DB::table(\"vipinfo\")->lists('vip_name'); //不指定下标，默认下标从0开始 //select()指定某个字段 $student=DB::table(\"vipinfo\")->select('vip_name','vip_ID')->get(); dd($student); //chunk()每次查n条 $student=DB::table(\"vipinfo\")->chunk(2,function($students){ //每次查2条 var_dump($students); if(.......) return false; //在满足某个条件下使用return就不会再往下查了 }); 二、使用聚合函数123456789101112//count()统计记录条数 $nums=DB::table(\"vipinfo\")->count(); echo $nums; //max()某个字段的最大值,同理min是最小值 $max=DB::table(\"vipinfo\")->max(\"vip_fenshu\"); echo $max; //avg()某个字段的平均值 $avg=DB::table(\"vipinfo\")->avg(\"vip_fenshu\"); echo $avg; //sum()某个字段的和 $sum=DB::table(\"vipinfo\")->sum(\"vip_fenshu\"); echo $sum; 数据库操作之 - Eloquent ORM一、简介 模型的建立及查询数据简介：laravel所自带的Eloquent ORM 是一个ActiveRecord实现，用于数据库操作。每个数据表都有一个与之对应的模型，用于数据表交互。 建立模型，在app目录下建立一个Student模型，即Student.php，不需要带任何后缀。123456789'StudentController@test3']); 1234567891011public function test3(){ // all()方法查询所有数据 $studnets=Student::all(); dd($studnets); //find()查询一条，依据主键查询。findOrFail()查找不存在的记录时会抛出异常 $student=Student::find(5); //主键为5的记录 var_dump($student['attributes']); //查询构造器的使用,省略了指定表名 $student=Student::get(); var_dump($student); } 二、新增数据、自定义时间戳、批量赋值1.新增数据（1）使用save方法新增laravel会默认维护created_at,updated_at 两个字段，这两个字段都是存储时间戳，整型11位的，因此使用时需要在数据库添加这两个字段。如果不需要这个功能，只需要在模型里加一个属性：1public $timestamps=false; 以及一个方法，可以将当前时间戳存到数据库123protected function getDateFormat(){ return time(); } 这样就不需要那两个字段了。控制器里写：1234567$student=new Student(); //设定数据 $student->vip_name='xiaoming'; $student->vip_type='出行'; $student->vip_fenshu=900; $bool=$student->save(); //保存 echo $bool; 从数据库里取得某条记录的时间戳时，默认取得的是按日期格式化好的时间戳，如果想取得原本的时间戳，则在模型里增加asDateTime方法。123protected function asDateTime($val){ return $val; } （2）使用create方法新增时，需要在模型里增加：1protected $fillable=['vip_name','vip_fenshu','vip_type']; //允许批量赋值的字段 控制器里写：1Student::create(['vip_name'=>'mmm','vip_fenshu'=>999,'vip_type'=>'出行']); 这样即可新增成功！（3）firstOrCreate()以属性查找记录，若没有则新增12$student=Student::firstOrCreate(['vip_name'=>'mmm']); echo $student; （4）firstOrNew()以属性查找记录，若没有则会创建新的实例。若需要保存，则自己调用save方法()123$student=Student::firstOrNew(['vip_name'=>'mmm']); $student->save(); echo $student; 2.修改数据123456//通过模型更新数据 $student=Student::find(2); $student->vip_fenshu=10000; $student->save(); //返回bool值 //通过查询构造器更新 $num=Student::where('vip_ID','>',2)->update(['vip_fenshu'=>2000]); echo $num; //返回更新的行数 3.删除数据12345678//(1)通过模型删除数据 $student=Student::find(11); $student->delete(); //返回bool值 //(2)通过主键删除 $num=Student::destroy(10); //删除主键为10的一条记录 echo $num; //返回删除的行数 $num=Student::destroy(10,5); //删除多条 或者$num=Student::destroy([10,5]); echo $num; //返回删除的行数 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"https://bingbingliang.github.io/tags/PHP/"}]},{"title":"markdown 常用转义字符","date":"2014-08-11T16:00:00.000Z","path":"/posts/ad603812/","text":"注意：转义字符中的 & 与 字母 中间没有空格，这里是有空格的 是为了防止转义。 ⊙﹏⊙‖∣° 真尴尬～～ 显示结果 描述 转义字符 空格 & nbsp; 大于号 & gt; & 和号 & amp; \" 双引号 & quot; ' 单引号 & apos;(IE不支持) 显示结果描述实体名称实体编号 空格& nbsp;& #160;大于号& gt;& #62;&和号& amp;& #38;\"双引号& quot;& #34;'单引号& apos;(IE不支持)& #39; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"hexo 常用命令","date":"2014-08-10T16:00:00.000Z","path":"/posts/16107/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start创建一个新帖子1$ hexo new \"My New Post\" More info: Writing 运行服务器1$ hexo server More info: Server 生成静态文件1$ hexo generate More info: Generating 部署到远程站点1$ hexo deploy More info: Deployment 清理缓存1$ hexo clean 总结常用命令写文章1$ hexo new [layout] \"title\" 你可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 布局（Layout）Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 1234布局 路径post source/_postspage sourcedraft source/_drafts hexo默认你的文件为post 然后你就可以运行 hexo server 来本地运行实时查看你写的文章，draft 为你的草稿文件夹，在创建文章的时候，只要指定文章的模板是draft，就可以将文章创建到source/_drafts/目录下： 1$ hexo new draft Test 这样就会将Test这篇文章作为草稿放到_drafts目录下了，draft模板是提前定义好的，在./scaffolds目录中。放在_drafts目录中的草稿，使用hexo g命令生成静态文件的时候，是不会将草稿也生成的。 如果想要查看草稿的效果，可以在启动本地服务的时候增加一个参数：hexo s –draft ，或者在 _config.yml文件中进行配置： 1render_drafts: true 这样每次启动本地服务的时候，都会渲染编写的草稿。 编写好草稿后，可以使用以下命令，将草稿发布到_posts目录中： 1$ hexo publish [layout] \"title\" 例如： 1$ hexo publish [post] Test post模板也是在./scaffolds目录中定义好的，发布命令执行后，_drafts目录中的草稿也就被移除掉了。 注意：hexo publish命令默认使用post模板。 通过对上面layout 情况为 post和 draft的阐释，大家应该会对layout大概会有个了解了。那么layout为page的时候到底会发生什么呢？ 我们尝试一下下面这个命令 1$ hexo new page “about” 这个时候你打开source文件夹你会发现一个about的文件夹，里面会有一个index.md的文件。 编辑index.md文件，像之前post和draft的情况一样，我们在其中输入一些测试的内容，然后依次执行hexo g，运行hexo s。 打开4000端口之后，你会发现你依然看不到你刚才编辑的index.md的内容。 那么这部分的内容到底在哪里呢？如何才能看到呢？我们将url增加‘/about’的内容，也就是说把url改为：‘http://localhost:4000/about’ 然后回车。这个时候你就会发现你刚才编辑的index.md的内容就会出现在这里。 其实，在你执行hexo g命令的时候，已经将index.md文件的内容生成在了public文件夹下面，你去public文件夹中寻找，会发现一个about文件夹，这个about文件夹下有一个index.html文件。 一般情况下，如果一个page下面没有输入具体的文件名的话，就会打开这个文件夹下的index.html文件。那么也就是是说，这个时候你去source/about文件夹下再去新建一个myPageIntroduction.md的文件，编辑完之后执行hexo g和hexo s,然后在地址栏输入url的内容为：’http://localhost:4000/about/myPageIntroduction.html’ 就会看到你刚才编辑的myPageIntroduction.md的内容。 这就是layout 为 page的时候的作用。其实就是相当于生成一个新的路径，也就是我们说的url的path，或者也可以称作路由。通过这种方式，我们可以把我们的博客再进行细分各个内容版块，更有条理的组织我们的博客。 关于layout为page的情况，官网似乎没有详细说明。所以上述关于page的内容是我自己的一个总结，这个似乎不能完全解释page的作用，但是仅仅从组织博客内容的版块来看，是可以应用和解释的。 本文部分内容参考链接：https://blog.csdn.net/abc_soul/article/details/83147583 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]}]