[{"title":"PHP上传大文件 - 配置upload_max_filesize和post_max_size","date":"2019-06-19T16:34:54.000Z","path":"/posts/ac09b59e/","text":"简介：PHP上传大文件所涉及到的 php.ini 配置详解。 upload_max_filesize = 2M该配置是指文件上传大小默认是 2M ，如果超过则会失败。必须更改upload_max_filesize的值，例如：upload_max_filesize = 20M。 post_max_size = 8M该配置是指 POST 的数据最大字节长度是8M。索性将这个也改为20M，让它与 upload_max_filesize 相等即可。 max_execution_time = 30该配置是指每个脚本运行的最长时间，单位：秒。在传大文件的时候，必然传输时间变长，当时间超过30秒时，会报脚本执行超过30秒的错误。所以需要适当调高一点，比如 max_execution_time=60。 max_input_time = 60该配置是指每个脚本可以消耗的时间，单位：秒。也需要适当调高一点，比如 max_input_time=120。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"https://bingbingliang.github.io/tags/PHP/"}]},{"title":"微信公众号 - 获取所有关注者的信息","date":"2019-06-18T16:34:54.000Z","path":"/posts/8aac5384/","text":"简介：使用微信公众号接口一键获取全部关注用户的信息。（openid,nickname,city,country,groupid,targetlist） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223&lt;?php //Get all user infors method with wechat PHP API set_time_limit(0); $count = 0; //appid of wechat $appid = '您的APPID'; //appsecret of wechat $appsecret = '您的appsecret'; //@description: convert the unicode to Chinese characters //@para:target string //@return:handled string function decodeUnicode($str) { return preg_replace_callback('/\\\\\\\\u([0-9a-f]{4})/i', create_function( '$matches', 'return mb_convert_encoding(pack(\"H*\", $matches[1]), \"UTF-8\", \"UCS-2BE\");' ),$str); } //@description: if the access_token is invaild, retrive the access_token and assign to global access_token function isErr($data){ if(array_key_exists('errcode',$data)){ //the limit times to retrive access_token(for there is a upper limit 2000 one day) if($GLOBALS['ERRCount'] > $GLOBALS['UpperLimit']){ return false; } if($data['errcode'] == 40001){ $GLOBALS['ERRCount'] = $GLOBALS['ERRCount'] + 1; $GLOBALS['access_token'] = getaccess_token($appid,$appsecret); return true; } else{ //other error but not access_token invaild return false; } } return false; } //@description:get the access_token function getaccess_token($appid,$appsecret){ //the access_token request url $url = \"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid={$appid}&secret={$appsecret}\"; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL,$url); curl_setopt($ch, CURLOPT_RETURNTRANSFER,1); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER,0); $data = curl_exec($ch); curl_close($ch); //convert json to array $data = json_decode($data,true); return $data['access_token']; } //@description: post method of get 100 user infors(limit:100 once) //@para:the first is access_token,the second is the post data which is a json string(format see wechat API website) //@return: the array of user infors function post($access_token, $post_data = ''){ $url = \"https://api.weixin.qq.com/cgi-bin/user/info/batchget?access_token={$access_token}\"; $ch = curl_init(); curl_setopt ($ch, CURLOPT_URL, $url); curl_setopt ($ch, CURLOPT_POST, 1); curl_setopt ($ch, CURLOPT_POSTFIELDS, $post_data); curl_setopt ($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt ($ch, CURLOPT_HEADER, false); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER,0); // the response data which is the infor json string $data = curl_exec($ch); curl_close($ch); // replace error json string to avoid decode error $data = preg_replace('/[\\x00-\\x1F]/','', $data); $data = json_decode($data,true); //var_dump($data); if(isErr($data)){ //if the access_token is invaild, retrive the new access_token and try again return post($GLOBALS['access_token'],$post_data); } if(array_key_exists('user_info_list',$data)){ return $data['user_info_list']; } } //@description: get the openids list of users(limit:10000 once) //@para: the first is the access_token,the second is the next_openid which could be empty as the default //@return: return the openid list function getOpenid($access_token,$openid=''){ //获取access_token $url = \"https://api.weixin.qq.com/cgi-bin/user/get?access_token={$access_token}&next_openid={$openid}\"; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL,$url); curl_setopt($ch, CURLOPT_RETURNTRANSFER,1); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER,0); $data = curl_exec($ch); curl_close($ch); $data = json_decode($data,true); if(isErr($data)){ return getOpenid($GLOBALS['access_token'],$openid); } return $data; } //@description: write the user infor to file or do other handle //para: user infor array function handInfors($data){ if($data == null){ return; } foreach($data as $infor){ //number count of all users $GLOBALS['InforCount'] = $GLOBALS['InforCount'] + 1; //unicode convert $inforJson = decodeUnicode(json_encode($infor)); //write each line(each user infor) to info.txt $file = 'info.txt'; $current = file_get_contents($file); $current .= $inforJson; $current .= \"\\r\\n\"; file_put_contents($file, $current); } } //@description: send model message to Specified openid //@return: the send response function set_msg($access_token,$openid){ $formwork = '{ \"touser\":\"'.$openid.'\", \"template_id\":\"GkChFMRCGYvGoNUzusXX3qnOOV-6U0L801L3lmp6NYo\", \"url\":\"http://mp.weixin.qq.com/s/Nn7-KIVOR3S8SFBOV3Qw8Q\", \"data\":{ \"first\": { \"value\":\"缠论运行报告\", \"color\":\"#173177\" }, \"keyword1\":{ \"value\":\"缠论\", \"color\":\"#173177\" }, \"keyword2\":{ \"value\":\"国信TradeStation缠论全市场扫描\", \"color\":\"#173177\" }, \"keyword3\":{ \"value\":\"每天\", \"color\":\"#173177\" }, \"remark\": { \"value\":\"2017-3-13：本日，\\n第一类买点：2只，第二类买点：1只，第三类买点：0只；\\n第一类卖点：1只，第二类卖点：0只，第三类卖点：2只；\\n点击查看详情。\", \"color\":\"#FF0000\" } } }'; $url = \"https://api.weixin.qq.com/cgi-bin/message/template/send?access_token={$access_token}\"; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL,$url); curl_setopt($ch, CURLOPT_RETURNTRANSFER,1); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER,0); curl_setopt($ch, CURLOPT_POST,1); curl_setopt($ch, CURLOPT_POSTFIELDS,$formwork); $data = curl_exec($ch); curl_close($ch); return $data; } //@description:get user infor by openid //@return: the user infor Json string function getUserByID($access_token,$openid){ $url = \"https://api.weixin.qq.com/cgi-bin/user/info?access_token={$access_token}&openid={$openid}&lang=zh_CN\"; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL,$url); curl_setopt($ch, CURLOPT_RETURNTRANSFER,1); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER,0); $data = curl_exec($ch); curl_close($ch); return $data;//return the infor json string } //main method: echo date('Y-m-d H:i:s',time()); echo(\"&lt;br&gt;&lt;/br&gt;\"); $access_token = getaccess_token($appid,$appsecret); echo \"access_token：\".$access_token; echo(\"&lt;br&gt;&lt;/br&gt;\"); $ERRCount = 0; $UpperLimit = 10; $InforCount = 0; $data = getOpenid($access_token); //print_r($data); //echo(\"&lt;br&gt;&lt;/br&gt;\"); while(true){ //getOpenid $count = $data['count']; //openids count(10000 or trim) $nextopenid = $data['next_openid']; $list = array(); $tempCount = 0; if(array_key_exists('data',$data) == false){ break; } foreach($data['data']['openid'] as $openid){ $tempCount = $tempCount + 1; $idArray =array( 'openid' => $openid, \"lang\" => \"zh-CN\" ); Array_push($list,$idArray); if(count($list) == 100 or $tempCount == $count){ $arra = array( 'user_list' => $list ); //echo(json_encode($arra)); //print_r($arra); $infors = post($access_token,json_encode($arra)); print_r($infors); echo(\"&lt;br&gt;&lt;/br&gt;\"); //write infors to files handInfors($infors); $list = array(); } } $data = getOpenid($access_token,$nextopenid); } echo date('Y-m-d H:i:s',time()); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"https://bingbingliang.github.io/tags/PHP/"}]},{"title":"微信公众号 - 自定义token对接","date":"2019-06-17T17:55:46.000Z","path":"/posts/e20321f4/","text":"简介：开发微信公众号之前需要先给“微信公众平台”与“自己的服务器”建立一个关系，本篇内容就是“自己的服务器”与“微信公众平台”对接的文件内容。 由于“微信公众号-被动回复用户消息”不需要 appID 和 appsecret ，所以我把该功能也引进了这篇文章。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;?php/** * wechat php test *///define your tokendefine(\"TOKEN\", \"weixin\"); // 自定义‘与微信公众平台-接口配置信息中的 token 一致才能对接成功’$wechatObj = new wechatCallbackapiTest();$wechatObj->valid();class wechatCallbackapiTest { public function valid() { $echoStr = $_GET[\"echostr\"]; //valid signature , option if($this->checkSignature() && $echoStr){ echo $echoStr; exit; } else { $this -> responseMsg(); } } public function responseMsg() { //get post data, May be due to the different environments //$postStr = $GLOBALS[\"HTTP_RAW_POST_DATA\"]; $postStr = file_get_contents(\"php://input\"); //extract post data if (!empty($postStr)){ $postObj = simplexml_load_string($postStr, 'SimpleXMLElement', LIBXML_NOCDATA); if( strtolower($postObj->MsgType) == 'text' && trim($postObj->Content)=='tuwen' ){ $fromUsername = $postObj->FromUserName; $toUsername = $postObj->ToUserName; $arr = array( array( 'title'=>'hao123', 'description'=>\"hao123 is very cool\", 'picUrl'=>'https://www.baidu.com/img/bdlogo.png', 'url'=>'http://www.hao123.com', ), array( 'title'=>'qq', 'description'=>\"qq is very cool\", 'picUrl'=>'http://www.imooc.com/static/img/common/logo.png', 'url'=>'http://www.qq.com', ), array( 'title'=>'imooc', 'description'=>\"imooc is very cool\", 'picUrl'=>'http://www.imooc.com/static/img/common/logo.png', 'url'=>'http://www.imooc.com', ), ); $template = \"&lt;xml&gt; &lt;ToUserName&gt&lt;![CDATA[%s]]&gt&lt;/ToUserName&gt &lt;FromUserName&gt&lt;![CDATA[%s]]&gt&lt;/FromUserName&gt &lt;CreateTime&gt%s&lt;/CreateTime&gt &lt;MsgType&gt&lt;![CDATA[%s]]&gt&lt;/MsgType&gt &lt;ArticleCount&gt3&lt;/ArticleCount&gt &lt;Articles&gt\"; foreach($arr as $k=>$v){ $template .=\"&#60;item&gt; &lt;Title&gt;&lt;![CDATA[\".$v['title'].\"]]&gt;&lt;/Title&gt; &lt;Description&gt;&lt;![CDATA[\".$v['description'].\"]]&gt;&lt;/Description&gt; &lt;PicUrl&gt;&lt;![CDATA[\".$v['picUrl'].\"]]&gt;&lt;/PicUrl&gt; &lt;Url&gt;&lt;![CDATA[\".$v['url'].\"]]&gt;&lt;/Url&gt; &lt;/item&gt;\"; } $template .=\"&lt;/Articles&gt; &lt;/xml&gt;\"; echo sprintf($template, $fromUsername, $toUsername, time(), 'news'); //注意：进行多图文发送时，子图文个数不能超过10个 }else{ $fromUsername = $postObj->FromUserName; $toUsername = $postObj->ToUserName; $keyword = trim($postObj->Content); $time = time(); $textTpl = \"&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;%s&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[%s]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt; &lt;FuncFlag&gt;0&lt;/FuncFlag&gt; &lt;/xml&gt;\"; $msgType = \"text\"; // 判断该数据包是否是订阅的事件推送 if( strtolower( $postObj->MsgType) == 'event'){ // 如果是关注 subscribe 事件 if( strtolower( $postObj->Event == 'subscribe')){ // 回复用户消息 $contentStr = \"欢迎关注我们的微信公众号\"; } }else if( strtolower( $postObj->MsgType) == 'text'){ switch ($keyword) { case 1: $contentStr = \"您输入了数字1\"; break; case 2: $contentStr = \"您输入了数字2\"; break; case '冰冰凉': $contentStr = \"&lt;a href='https://bingbingliang.github.io'&gt;冰冰凉&lt;/a&gt;\"; break; default: $contentStr = \"未匹配到您的输入\"; break; } } $resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr); echo $resultStr; } }else { echo \"\"; exit; } } private function checkSignature() { $signature = $_GET[\"signature\"]; $timestamp = $_GET[\"timestamp\"]; $nonce = $_GET[\"nonce\"]; $token = TOKEN; $tmpArr = array($token, $timestamp, $nonce); sort($tmpArr); $tmpStr = implode( $tmpArr ); $tmpStr = sha1( $tmpStr ); if( $tmpStr == $signature ){ return true; }else{ return false; } }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"https://bingbingliang.github.io/tags/PHP/"}]},{"title":"递归方法","date":"2019-01-04T16:00:00.000Z","path":"/posts/14182/","text":"12345678910111213141516171819// 调用递归方法public function sel(){ $arr = $this->Table('region')->select(); return $this->level_sel($arr,$parent_id=0,$level=0);}// 递归function level_sel($arr,$parent_id=0,$level=0){ // 定义一个静态数组 static $data = array(); foreach($arr as $key=>$val){ if($val['parent_id'] == $parent_id){ $val['level'] == $level; $data[] = $val; $this->level_sel($arr,$val['r_id'],$level+1); } } return $data;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"https://bingbingliang.github.io/tags/PHP/"}]},{"title":"PHPStorm 相关操作","date":"2019-01-02T16:00:00.000Z","path":"/posts/13173/","text":"PHPStorm 设置 Ctrl + 滚轮调整字体大小1.点击左上角的File，再点击setting； 2.Editor->General，选择Change font size (Zoom) with Ctrl+Mouse Wheel； 3.点击OK即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"https://bingbingliang.github.io/tags/PHP/"}]},{"title":"MySQL 数据库的常用命令","date":"2018-12-31T16:00:00.000Z","path":"/posts/57951/","text":"如何使用命令行把 sql 文件导入 MySql 数据库1.进入 MySql ：mysql -uroot -p；（配置全局变量的情况下可直接进入，否则需要进入mysql的安装目录bin下进行进入） 2.使用需要导入到的数据库：use 3.导入 sql 文件到当前数据库：source sql 文件路径 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"MySql","slug":"MySql","permalink":"https://bingbingliang.github.io/tags/MySql/"}]},{"title":"Laravel 数据库操作的三种方式","date":"2017-12-31T16:00:00.000Z","path":"/posts/49682/","text":"Laravel提供了3种操作数据库方式：DB facade（原始方式）、查询构造器和Eloquent ORM。 数据库操作之DB facade1.查询操作12//返回一个二维数组DB::select(\"select * from table\"); 2.新增操作12//新增成功则返回trueDB::insert(\"insert into table(vip_ID,vip_name,vip_type,vip_fenshu) values(?,?,?,?)\",[5,'小明','出行',670]); 3.更新操作12//更新成功返回trueDB::update('update vipinfo set vip_fenshu= ? where vip_ID= ? ',[700,5]); 4.删除操作12// 返回的是删除的行数。DB::delete('delete from vipinfo where vip_ID= ?',[5]); 数据库操作之查询构造器一、使用查询构造器实现增删改查1.新增1234567891011$bool=DB::table(\"vipinfo\")->insert(['vip_ID'=>6,'vip_name'=>'zls','vip_type'=>\"出行\",'vip_fenshu'=>800]); echo $bool; //返回bool值 //如果想得到新增的id，则使用insertGetId方法 $id=DB::table(\"vipinfo\")->insertGetId(['vip_ID'=>5,'vip_name'=>'wyp','vip_type'=>\"出行\",'vip_fenshu'=>800]); echo $id; //插入多条数据 $bool=DB::table(\"vipinfo\")->insert([ ['vip_ID'=>5,'vip_name'=>'wyp','vip_type'=>\"出行\",'vip_fenshu'=>800], ['vip_ID'=>6,'vip_name'=>'zls','vip_type'=>\"出行\",'vip_fenshu'=>800], ]); echo $bool; //返回bool值 2.修改1234567891011121314151617181920212223$bool=DB::table(\"vipinfo\")->where('vip_ID',6)->update(['vip_fenshu'=>500]); echo $bool; //自增 $bool=DB::table(\"vipinfo\")->where('vip_ID',6)->increment(\"vip_fenshu\");//自增1 $bool=DB::table(\"vipinfo\")->where('vip_ID',6)->increment(\"vip_fenshu\",3);//自增3 echo $bool; //自减 $bool=DB::table(\"vipinfo\")->where('vip_ID',6)->decrement(\"vip_fenshu\");//自1 $bool=DB::table(\"vipinfo\")->where('vip_ID',6)->decrement(\"vip_fenshu\",3);//自增3 echo $bool; //自增时再修改其他字段 $bool=DB::table(\"vipinfo\")->where('vip_ID',6)->increment(\"vip_fenshu\",3,['vip_name'=>'dbdibi']);//自增3//两个字段同时自增 or 自减 increment// 第一种写法$results = DB::table('articles') ->where('id', $params['id']) ->increment('vote', 1, array('num' => DB::raw('`num` + 1')));// 第二种写法$results = DB::table('articles')->where('id', $params['id'])->update(array( 'vote' => DB::raw('vote + 1'), 'num' => DB::raw('num + 1'),)); 3.删除1234$num=DB::table(\"vipinfo\")->where('vip_ID',6)->delete();//删除1条 $num=DB::table(\"vipinfo\")->where('vip_ID','>',4)->delete();//删除多条 echo $num; //删除的行数 $num=DB::table(\"vipinfo\")->truncate();//删除整表，不能恢复，谨慎使用 4.查询1234567891011121314151617181920212223242526//get()返回多条数据 $student=DB::table(\"vipinfo\")->get(); var_dump($student); //first()返回1条数据 $student=DB::table(\"vipinfo\")->first(); //结果集第一条记录 $student=DB::table(\"vipinfo\")->orderBy('vip_ID','desc')->first();//按vip_ID倒序排序 var_dump($student); //where()条件查询 $student=DB::table(\"vipinfo\")->where('vip_ID','>=',2)->get(); //一个条件 $student=DB::table(\"vipinfo\")->whereRaw('vip_ID> ? and vip_fenshu >= ?',[2,300])->get(); //多个条件 dd($student); //pluck()指定字段,后面不加get $student=DB::table(\"vipinfo\")->pluck('vip_name'); dd($student); //lists()指定字段，可以指定某个字段作为下标 $student=DB::table(\"vipinfo\")->lists('vip_name','vip_ID'); //指定vip_ID为下标 dd($student); $student=DB::table(\"vipinfo\")->lists('vip_name'); //不指定下标，默认下标从0开始 //select()指定某个字段 $student=DB::table(\"vipinfo\")->select('vip_name','vip_ID')->get(); dd($student); //chunk()每次查n条 $student=DB::table(\"vipinfo\")->chunk(2,function($students){ //每次查2条 var_dump($students); if(.......) return false; //在满足某个条件下使用return就不会再往下查了 }); 二、使用聚合函数123456789101112//count()统计记录条数 $nums=DB::table(\"vipinfo\")->count(); echo $nums; //max()某个字段的最大值,同理min是最小值 $max=DB::table(\"vipinfo\")->max(\"vip_fenshu\"); echo $max; //avg()某个字段的平均值 $avg=DB::table(\"vipinfo\")->avg(\"vip_fenshu\"); echo $avg; //sum()某个字段的和 $sum=DB::table(\"vipinfo\")->sum(\"vip_fenshu\"); echo $sum; 数据库操作之 - Eloquent ORM一、简介 模型的建立及查询数据简介：laravel所自带的Eloquent ORM 是一个ActiveRecord实现，用于数据库操作。每个数据表都有一个与之对应的模型，用于数据表交互。 建立模型，在app目录下建立一个Student模型，即Student.php，不需要带任何后缀。123456789'StudentController@test3']); 1234567891011public function test3(){ // all()方法查询所有数据 $studnets=Student::all(); dd($studnets); //find()查询一条，依据主键查询。findOrFail()查找不存在的记录时会抛出异常 $student=Student::find(5); //主键为5的记录 var_dump($student['attributes']); //查询构造器的使用,省略了指定表名 $student=Student::get(); var_dump($student); } 二、新增数据、自定义时间戳、批量赋值1.新增数据（1）使用save方法新增laravel会默认维护created_at,updated_at 两个字段，这两个字段都是存储时间戳，整型11位的，因此使用时需要在数据库添加这两个字段。如果不需要这个功能，只需要在模型里加一个属性：1public $timestamps=false; 以及一个方法，可以将当前时间戳存到数据库123protected function getDateFormat(){ return time(); } 这样就不需要那两个字段了。控制器里写：1234567$student=new Student(); //设定数据 $student->vip_name='xiaoming'; $student->vip_type='出行'; $student->vip_fenshu=900; $bool=$student->save(); //保存 echo $bool; 从数据库里取得某条记录的时间戳时，默认取得的是按日期格式化好的时间戳，如果想取得原本的时间戳，则在模型里增加asDateTime方法。123protected function asDateTime($val){ return $val; } （2）使用create方法新增时，需要在模型里增加：1protected $fillable=['vip_name','vip_fenshu','vip_type']; //允许批量赋值的字段 控制器里写：1Student::create(['vip_name'=>'mmm','vip_fenshu'=>999,'vip_type'=>'出行']); 这样即可新增成功！（3）firstOrCreate()以属性查找记录，若没有则新增12$student=Student::firstOrCreate(['vip_name'=>'mmm']); echo $student; （4）firstOrNew()以属性查找记录，若没有则会创建新的实例。若需要保存，则自己调用save方法()123$student=Student::firstOrNew(['vip_name'=>'mmm']); $student->save(); echo $student; 2.修改数据123456//通过模型更新数据 $student=Student::find(2); $student->vip_fenshu=10000; $student->save(); //返回bool值 //通过查询构造器更新 $num=Student::where('vip_ID','>',2)->update(['vip_fenshu'=>2000]); echo $num; //返回更新的行数 3.删除数据12345678//(1)通过模型删除数据 $student=Student::find(11); $student->delete(); //返回bool值 //(2)通过主键删除 $num=Student::destroy(10); //删除主键为10的一条记录 echo $num; //返回删除的行数 $num=Student::destroy(10,5); //删除多条 或者$num=Student::destroy([10,5]); echo $num; //返回删除的行数 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"https://bingbingliang.github.io/tags/PHP/"}]},{"title":"markdown 常用转义字符","date":"2016-08-11T16:00:00.000Z","path":"/posts/ad603812/","text":"注意：转义字符中的 & 与 字母 中间没有空格，这里是有空格的 是为了防止转义。 ⊙﹏⊙‖∣° 真尴尬～～ 显示结果 描述 转义字符 空格 & nbsp; 大于号 & gt; & 和号 & amp; \" 双引号 & quot; ' 单引号 & apos;(IE不支持) 显示结果描述实体名称实体编号 空格& nbsp;& #160;大于号& gt;& #62;&和号& amp;& #38;\"双引号& quot;& #34;'单引号& apos;(IE不支持)& #39; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"hexo 常用命令","date":"2016-08-10T16:00:00.000Z","path":"/posts/16107/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start创建一个新帖子1$ hexo new \"My New Post\" More info: Writing 运行服务器1$ hexo server More info: Server 生成静态文件1$ hexo generate More info: Generating 部署到远程站点1$ hexo deploy More info: Deployment 清理缓存1$ hexo clean 总结常用命令写文章1$ hexo new [layout] \"title\" 你可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 布局（Layout）Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 1234布局 路径post source/_postspage sourcedraft source/_drafts hexo默认你的文件为post 然后你就可以运行 hexo server 来本地运行实时查看你写的文章，draft 为你的草稿文件夹，在创建文章的时候，只要指定文章的模板是draft，就可以将文章创建到source/_drafts/目录下： 1$ hexo new draft Test 这样就会将Test这篇文章作为草稿放到_drafts目录下了，draft模板是提前定义好的，在./scaffolds目录中。放在_drafts目录中的草稿，使用hexo g命令生成静态文件的时候，是不会将草稿也生成的。 如果想要查看草稿的效果，可以在启动本地服务的时候增加一个参数：hexo s –draft ，或者在 _config.yml文件中进行配置： 1render_drafts: true 这样每次启动本地服务的时候，都会渲染编写的草稿。 编写好草稿后，可以使用以下命令，将草稿发布到_posts目录中： 1$ hexo publish [layout] \"title\" 例如： 1$ hexo publish [post] Test post模板也是在./scaffolds目录中定义好的，发布命令执行后，_drafts目录中的草稿也就被移除掉了。 注意：hexo publish命令默认使用post模板。 通过对上面layout 情况为 post和 draft的阐释，大家应该会对layout大概会有个了解了。那么layout为page的时候到底会发生什么呢？ 我们尝试一下下面这个命令 1$ hexo new page “about” 这个时候你打开source文件夹你会发现一个about的文件夹，里面会有一个index.md的文件。 编辑index.md文件，像之前post和draft的情况一样，我们在其中输入一些测试的内容，然后依次执行hexo g，运行hexo s。 打开4000端口之后，你会发现你依然看不到你刚才编辑的index.md的内容。 那么这部分的内容到底在哪里呢？如何才能看到呢？我们将url增加‘/about’的内容，也就是说把url改为：‘http://localhost:4000/about’ 然后回车。这个时候你就会发现你刚才编辑的index.md的内容就会出现在这里。 其实，在你执行hexo g命令的时候，已经将index.md文件的内容生成在了public文件夹下面，你去public文件夹中寻找，会发现一个about文件夹，这个about文件夹下有一个index.html文件。 一般情况下，如果一个page下面没有输入具体的文件名的话，就会打开这个文件夹下的index.html文件。那么也就是是说，这个时候你去source/about文件夹下再去新建一个myPageIntroduction.md的文件，编辑完之后执行hexo g和hexo s,然后在地址栏输入url的内容为：’http://localhost:4000/about/myPageIntroduction.html’ 就会看到你刚才编辑的myPageIntroduction.md的内容。 这就是layout 为 page的时候的作用。其实就是相当于生成一个新的路径，也就是我们说的url的path，或者也可以称作路由。通过这种方式，我们可以把我们的博客再进行细分各个内容版块，更有条理的组织我们的博客。 关于layout为page的情况，官网似乎没有详细说明。所以上述关于page的内容是我自己的一个总结，这个似乎不能完全解释page的作用，但是仅仅从组织博客内容的版块来看，是可以应用和解释的。 本文部分内容参考链接：https://blog.csdn.net/abc_soul/article/details/83147583 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]}]